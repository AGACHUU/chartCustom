<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gauge Chart with Custom Gradient</title>
    <!-- Chart.js 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        background-color: #03071f; /* 배경색 설정 */
        color: white;
        font-family: Arial, sans-serif;
      }
      .chart-container {
        width: 160px;
        height: 98px;
        position: relative;
      }
      .custom-legend {
        text-align: center;
        margin-top: 5px;
        font-size: 14px;
      }
      div.legendValue span.amountValue {
        color: rgba(132, 166, 255, 1);
      }

      canvas {
        filter: drop-shadow(0px 0px 4px rgba(0, 0, 0, 0.35));
      }
    </style>
  </head>
  <body>
    <!-- 차트를 그릴 캔버스 요소를 포함한 컨테이너 -->
    <div class="chart-container">
      <canvas id="gaugeChart"></canvas>
      <div class="custom-legend">
        <div class="legendValue" id="legendText">
          <span class="presentValue">1,000 m²</span> / <span class="amountValue">500 m²</span>
        </div>
      </div>
    </div>
    <script>
      let totalAmount = 1500;
      // 캔버스 요소를 가져와 2D 컨텍스트를 얻습니다
      const ctx = document.getElementById("gaugeChart").getContext("2d");

      // 게이지의 초기값 설정 (80%)
      let gaugeValue = 80;

      function createRadialGradient(ctx) {
        const gradient = ctx.createRadialGradient(80, 49, 0, 80, 49, 80);
        gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(1, "rgba(34, 210, 234, 1)");
        return gradient;
      }
      // 차트 데이터 정의
      const data = {
        datasets: [
          {
            data: [gaugeValue, 100 - gaugeValue],
            backgroundColor: [createRadialGradient(ctx), "rgba(187, 238, 252, 0.2)"],
            borderWidth: 0,
          },
        ],
      };

      // 중앙에 표시될 값을 추적하는 변수
      let centerValue = gaugeValue;

      // Chart.js를 사용하여 차트를 생성
      const gaugeChart = new Chart(ctx, {
        type: "doughnut", // 도넛 차트 타입 사용
        data: data,
        options: {
          circumference: 180, // 반원을 만들기 위해 180도로 설정
          rotation: -90, // 차트를 회전하여 반원이 위쪽을 향하도록 함
          cutout: "80%", // 내부 cutout 비율 (게이지 두께 조절)
          responsive: true, // 차트의 크기가 부모 컨테이너에 맞춰 조정되도록 설정
          maintainAspectRatio: false, // 컨테이너 비율에 맞추는 옵션
          plugins: {
            tooltip: { enabled: false }, // 툴팁 비활성화
            legend: { display: false }, // 범례 숨김
          },
          layout: {
            padding: 0,
          },
        },
        ///////////////////////////////
        plugins: [
          {
            id: "shadow-plugin",
            beforeDraw: (chart) => {
              //beforeDraw는 차트가 그려지기 전에 시작되는 훅함수.
              const { ctx, width, height } = chart;
              //ctx는 렌더링 2d컨텍스트, width,height차트캔버스의 너비와 높이.  shadow-plugin차트 아래 반원 모양 그라데이션 그림자를 그림. 여러개의 작은 동그라미로 구성됨.
              const x = width / 2; // 왼쪽 끝에서 차트 너비의 절반만큼이 중앙임
              const y = height - 10; // 위에서 부터 차트 높이길이만큼 떨어진 위치. 이유는 모르겠는데 차트높이가 보이는 것보다 10px 마진이 있어서, 그만큼 빼줌.
              const radius = (width / 2) * 0.7; // 게이지의 70%
              const totalStartAngle = Math.PI; // - 180도 그림자의 시작
              const totalEndAngle = 0; // 0도 끝각도
              const counterClockwise = false; // 시계 방향

              const lineCount = 40; // dash 개수

              const unitAngle = Math.abs(totalEndAngle - totalStartAngle) / lineCount; // dash + gap 각도
              const gapAngle = unitAngle / 2; // dash 각도

              for (let i = 0; i < lineCount; i++) {
                //이 루프는 lineCount만큼 반복하면서 각각의 호를 그립니다. 각 호는 조금씩 다른 각도와 투명도를 가지고이를 통해 그라데이션 효과를 줌
                ctx.save();
                ctx.beginPath();

                const startAngle = totalStartAngle + unitAngle * i; // 작은 대시 하나의 시작 각도
                const endAngle = startAngle + gapAngle; // 작은 대시 하나의 끝 각도

                const alpha = i / lineCount; // 투명도를 0에서 1까지 증가시킴, lineCount 만큼 등분. 0/40, 1/40, 2/40, ... 40/40

                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`; // 선 색상 설정
                ctx.lineWidth = 2; // 선 두께 설정

                // x, y, radius, startAngle, endAngle
                ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);

                ctx.stroke();
                ctx.restore();
              }
            },
          },
          /////////////////////////////

          {
            id: "centerText",
            afterDraw: (chart) => {
              const width = chart.width;
              const height = chart.height;
              const ctx = chart.ctx;

              ctx.save();
              ctx.font = "bold 36px Arial"; // 폰트 설정
              ctx.fillStyle = "rgb(255, 255, 255)"; // 텍스트 색상 설정
              ctx.textBaseline = "start";
              ctx.textAlign = "center";

              // 중앙에 값 표시
              const text = `${centerValue}%`;
              const textX = width / 2;
              const textY = height * 0.85;

              ctx.fillText(text, textX, textY);
              ctx.restore();
            },
          },
        ],
      });

      // 커스텀 범례 업데이트 함수
      // function updateLegend(current, total) {
      //   document.getElementById("legendText").textContent = `${current} m² /${total} m²`;
      // }

      function updateLegend(current, total) {
        document.getElementById(
          "legendText"
        ).innerHTML = `<span class="presentValue">${current} m²</span> / <span class="amountValue">${total} m²</span>`;
      }
      // 초기 범례 설정
      updateLegend(0, 1500);
    </script>
  </body>
</html>
