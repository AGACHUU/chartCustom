<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gauge Chart with Custom Gradient</title>
    <!-- Chart.js 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        background-color: #03071f; /* 배경색 설정 */
        color: white;
        font-family: Arial, sans-serif;
      }
      .chart-container {
        width: 160px;
        height: 98px;
        position: relative;
      }
      .custom-legend {
        text-align: center;
        margin-top: 5px;
        font-size: 14px;
      }
      div.legendValue span.amountValue {
        color: rgba(132, 166, 255, 1);
      }

      canvas {
        filter: drop-shadow(0px 0px 4px rgba(0, 0, 0, 0.35));
      }
    </style>
  </head>
  <body>
    <!-- 차트를 그릴 캔버스 요소를 포함한 컨테이너 -->
    <div class="chart-container">
      <canvas id="gaugeChart"></canvas>
      <div class="custom-legend">
        <div class="legendValue" id="legendText">
          <span class="presentValue">1,000 m²</span> / <span class="amountValue">500 m²</span>
        </div>
      </div>
    </div>
    <script>
      // 새로 추가된 부분: totalAmount 변수 선언
      let totalAmount = 1500; // 기본값 설정, 필요에 따라 변경 가능

      // 캔버스 요소를 가져와 2D 컨텍스트를 얻습니다
      const ctx = document.getElementById("gaugeChart").getContext("2d");

      // 게이지의 초기값 설정 (80%)
      let gaugeValue = 80;
      const totalV = 1000;
      const currentV = 400;
      /////이부분을 꼭 변수로 만들어야하는거임 1000이 총이고 큐랜트가 현재인데 백에서 받아올 데이터를 하드코딩으로 우리가 넣어준것 이것부터 이해해ㅑ야함////

      function createRadialGradient(ctx) {
        const gradient = ctx.createRadialGradient(80, 49, 0, 80, 49, 80);
        gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(1, "rgba(34, 210, 234, 1)");
        return gradient;
      }
      // 차트 데이터 정의
      const data = {
        datasets: [
          {
            data: [gaugeValue, 100 - gaugeValue],
            backgroundColor: [createRadialGradient(ctx), "rgba(187, 238, 252, 0.2)"],
            borderWidth: 0,
          },
        ],
      };

      // 중앙에 표시될 값을 추적하는 변수
      let centerValue = gaugeValue;

      // Chart.js를 사용하여 차트를 생성
      const gaugeChart = new Chart(ctx, {
        type: "doughnut", // 도넛 차트 타입 사용
        data: data,
        options: {
          circumference: 180, // 반원을 만들기 위해 180도로 설정
          rotation: -90, // 차트를 회전하여 반원이 위쪽을 향하도록 함
          cutout: "80%", // 내부 cutout 비율 (게이지 두께 조절)
          responsive: true, // 차트의 크기가 부모 컨테이너에 맞춰 조정되도록 설정
          maintainAspectRatio: false, // 컨테이너 비율에 맞추는 옵션
          plugins: {
            tooltip: { enabled: false }, // 툴팁 비활성화
            legend: { display: false }, // 범례 숨김
          },
          layout: {
            padding: 0,
          },
        },
        plugins: [
          {
            id: "shadow-plugin",
            beforeDraw: (chart) => {
              //beforeDraw는 차트가 그려지기 전에 시작되는 훅함수.
              const { ctx, width, height } = chart;
              //ctx는 렌더링 2d컨텍스트, width,height차트캔버스의 너비와 높이.  shadow-plugin차트 아래 반원 모양 그라데이션 그림자를 그림. 여러개의 작은 동그라미로 구성됨.
              const x = width / 2; // 왼쪽 끝에서 차트 너비의 절반만큼이 중앙임
              const y = height - 10; // 위에서 부터 차트 높이길이만큼 떨어진 위치. 이유는 모르겠는데 차트높이가 보이는 것보다 10px 마진이 있어서, 그만큼 빼줌.
              const radius = (width / 2) * 0.7; // 게이지의 70%
              const totalStartAngle = Math.PI; // - 180도 그림자의 시작 마이너스를 지워도 같은 이유는 clockotherwise 변수가 시계방향으로 되어있어서
              const totalEndAngle = 0; // 0도 끝각도
              const counterClockwise = false; // 시계 방향

              const lineCount = 40; // dash 개수

              const unitAngle = Math.abs(totalEndAngle - totalStartAngle) / lineCount; // dash + gap 각도
              const gapAngle = unitAngle / 2; // dash 각도

              for (let i = 0; i < lineCount; i++) {
                //이 루프는 lineCount만큼 반복하면서 각각의 호를 그립니다. 각 호는 조금씩 다른 각도와 투명도를 가지고이를 통해 그라데이션 효과를 줌
                ctx.save();
                ctx.beginPath();

                const startAngle = totalStartAngle + unitAngle * i; // 작은 대시 하나의 시작 각도
                const endAngle = startAngle + gapAngle; // 작은 대시 하나의 끝 각도

                const alpha = i / lineCount; // 투명도를 0에서 1까지 증가시킴, lineCount 만큼 등분. 0/40, 1/40, 2/40, ... 40/40

                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`; // 선 색상 설정
                ctx.lineWidth = 2; // 선 두께 설정

                // x, y, radius, startAngle, endAngle
                ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);

                ctx.stroke();
                ctx.restore();
              }
            },
          },
          {
            id: "centerText",
            afterDraw: (chart) => {
              const width = chart.width;
              const height = chart.height;
              const ctx = chart.ctx;

              ctx.save();
              ctx.font = "bold 36px Arial"; // 폰트 설정
              ctx.fillStyle = "rgb(255, 255, 255)"; // 텍스트 색상 설정
              ctx.textBaseline = "start";
              ctx.textAlign = "center";

              // 퍼센트숫자부분  계산 하는부분
              const percentage = Math.round((currentV / totalV) * 100); //100을곱해서 퍼센테이지화 시킴.
              const text = `${percentage}%`; //이부분이 문자열로 만드는거
              const textX = width / 2; //정중앙 표시
              const textY = height * 0.85; //높이 지정 팔십오프로위치에 택스트 배치

              ctx.fillText(text, textX, textY); //캔버스에 변수를 그림.
              ctx.restore(); // 이전에 저장된 캔버스 복원
            },
          },
        ],
      });

      // 범례 텍스트를 업데이트 하는 업데이트 레전드임.
      function updateLegend() {
        document.getElementById(
          "legendText"
        ).innerHTML = `<span class="presentValue">${currentV} m²</span> / <span class="amountValue">${totalAmount} m²</span>`;
        //id로 찾은요소의  html내용을 변경해준ㅁ
      }

      // 차트의  데이터 표시 업데이트
      function updateChart(currentValue) {
        centerValue = currentValue;
        //gaugeValue = (currentValue / totalAmount) * 100;
        //지금 얼만큼 차지하고 있는 밸류를 구하는 계산법 총 량을 지금 차지하고 있는 값을 나누고 비율을 퍼센테이지로 변환하기 위한 100을 곱해준다.
        // gaugeChart.data.datasets[0].data = [currentValue, 100 - currentValue];
        // 채워진 부분, 나눠진 부분 을 의미해줌 100-에서ㅏ 예를 들어 게이지벨유가 70이면
        //삼십이 남는데 그걸로 비워진 부분 채워진 부분 나눌수 있고 그걸 시각적으로 표현
        updateLegend(currentValue);
        //차트데이터를 업데이트 하고
      }

      // setTotalAmount 함수: 총 토탈 밸유 data를  변경해주는 하고 업데이트 해줌.
      function setTotalAmount(totalValue) {
        totalAmount = totalValue;
        updateChart(centerValue); // 현재 값으로 차트 다시 업데이트 해주기
      }

      // 수정된 부분: 초기 설정
      updateChart(0);

      setTotalAmount(totalV);

      ///////////////////// 게이지차오르게 코드 부분 /////////////////////
      const Gdata = Math.round((currentV / totalV) * 100);
      //Math.round(): 이 함수는 괄호 안의 숫자를 반올림합니다. 즉, 소수점 이하를 반올림하여 가장 가까운 정수로만듬

      // 차트 업데이트
      updateChart(Gdata);
      /////////////////////////////////////////////////////////////////////
    </script>
  </body>
</html>
